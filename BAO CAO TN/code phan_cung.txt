#include <WiFi.h>
#include <PubSubClient.h>
#include <WiFiClientSecure.h>
#include <ArduinoJson.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ILI9341.h>
#include <SPI.h>
//khai bao cam bien dat
#define RO_PIN 32  
#define DI_PIN 33  
#define DE_PIN 25  
#define RE_PIN 26

#define LIGHT_PIN 13
#define PUMP_PIN 14
#define FAN_PIN 27  //thu3 
//khai bao nut nhan
#define LIGHT_BTN_PIN 5   
#define ROOF_BTN_PIN 4  
#define PUMP_BTN_PIN 17   
#define FAN_BTN_PIN 16
//khai bao man
#define TFT_CS   18
#define TFT_RST  19
#define TFT_DC   21
#define TFT_MOSI 22
#define TFT_SCLK 23
Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC, TFT_RST);

#define UPDATE_INTERVAL 5000
#define SERIAL_BAUD 115200
#define NPK_BAUD 4800
#define BUFFER_SIZE 256

const char* SSID = "phuc";
const char* PASSWORD = "123456789";
const char* MQTT_SERVER = "4024dc14ff38445e99fe28aa9eb2eac3.s1.eu.hivemq.cloud";
const int MQTT_PORT = 8883;
const char* MQTT_USERNAME = "zed1126";
const char* MQTT_PASSWORD = "Phuc0912630035#";

HardwareSerial npkSerial(1);  // sử dụng UART1
//SoftwareSerial npkSerial(RO_PIN, DI_PIN);
WiFiClientSecure espClient;
PubSubClient client(espClient);

const byte QUERY_DATA[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x07, 0x04, 0x08};
const size_t RESPONSE_SIZE = 19;

const int IN1 = 2;               
const int IN2 = 15;             
const int limitSwitchClose = 35; 
const int limitSwitchOpen = 34;

bool lightStatus = false;
bool pumpStatus = false;
bool isOpening = false;  
bool isRunning = false; 
bool fanStatus = false; 

const unsigned long DEBOUNCE_DELAY = 50;    
const unsigned long DISPLAY_INTERVAL = 1000;
unsigned long lastDisplayUpdate = 0;

struct ButtonState {
    bool lastReading;
    bool state;
    bool lastState;
    unsigned long lastDebounceTime;
    bool changed;
};

ButtonState buttons[4] = {
    {HIGH, HIGH, HIGH, 0, false}, // Đèn
    {HIGH, HIGH, HIGH, 0, false}, // Mái che
    {HIGH, HIGH, HIGH, 0, false}, // Máy bơm
    {HIGH, HIGH, HIGH, 0, false}  // Quạt
};

struct LimitSwitchState {
    bool lastReading;
    bool state;
    unsigned long lastDebounceTime;
};
LimitSwitchState limitSwitches[2] = {
    {HIGH, HIGH, 0}, // Mở 
    {HIGH, HIGH, 0}  // Đóng
};

struct SoilData {
    float temperature;
    float humidity;
    uint16_t nitrogen;
    uint16_t phosphorus;
    uint16_t potassium;
    float ph;
};

struct DeviceStatus {
    bool light;
    bool roof;
    bool pump;
    bool fan;
};
DeviceStatus lastDeviceStatus = {false, false, false, false};
SoilData lastData = {0, 0, 0, 0, 0, 0};

void setup() {
    Serial.begin(SERIAL_BAUD);    

    SPI.begin(TFT_SCLK, -1, TFT_MOSI, TFT_CS);
    tft.begin();
    tft.setRotation(2);
    tft.fillScreen(ILI9341_BLACK);

    pinMode(DE_PIN, OUTPUT);
    pinMode(RE_PIN, OUTPUT);
    digitalWrite(DE_PIN, LOW);
    digitalWrite(RE_PIN, LOW);

    pinMode(LIGHT_PIN, OUTPUT);
    pinMode(PUMP_PIN, OUTPUT);
    pinMode(FAN_PIN, OUTPUT);
    digitalWrite(LIGHT_PIN, LOW);
    digitalWrite(PUMP_PIN, LOW);
    digitalWrite(FAN_PIN, LOW);

    pinMode(IN1, OUTPUT);
    pinMode(IN2, OUTPUT);
    pinMode(limitSwitchClose, INPUT); 
    pinMode(limitSwitchOpen, INPUT);  
    stopMotor(); 

    pinMode(LIGHT_BTN_PIN, INPUT_PULLUP);
    pinMode(ROOF_BTN_PIN, INPUT_PULLUP);
    pinMode(PUMP_BTN_PIN, INPUT_PULLUP);
    pinMode(FAN_BTN_PIN, INPUT_PULLUP);

    //npkSerial.begin(NPK_BAUD);
    npkSerial.begin(NPK_BAUD, SERIAL_8N1, RO_PIN, DI_PIN);
    setupWiFi();
    espClient.setInsecure();
    client.setServer(MQTT_SERVER, MQTT_PORT);
    client.setCallback(mqttCallback);

    tft.setTextSize(2);
    tft.setTextColor(ILI9341_WHITE);
    tft.setCursor(10, 10);
    tft.println("Initializing...");

    tft.setTextSize(3);
    tft.fillRect(10, 190, 230, 30, ILI9341_BLACK);
    tft.setCursor(10, 190);
    tft.setTextColor(ILI9341_RED); 
    tft.printf("LIGHT: OFF");

    tft.fillRect(10, 220, 230, 30, ILI9341_BLACK);
    tft.setCursor(10, 220);
    tft.setTextColor(ILI9341_RED); 
    tft.printf("ROOF : CLOSE");

    tft.fillRect(10, 250, 230, 30, ILI9341_BLACK);
    tft.setCursor(10, 250);
    tft.setTextColor(ILI9341_RED); 
    tft.printf("PUMP : OFF");

    tft.fillRect(10, 280, 230, 30, ILI9341_BLACK);
    tft.setCursor(10, 280);
    tft.setTextColor(ILI9341_RED);
    tft.printf("FAN  : OFF");
}

void setupWiFi() {
    WiFi.begin(SSID, PASSWORD);
    Serial.printf("Connecting to %s", SSID);
    
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }
    Serial.printf("\nConnected, IP: %s\n", WiFi.localIP().toString().c_str());
}
// Nhận lệnh từ MQTT
void mqttCallback(char* topic, byte* payload, unsigned int length) {
    String message = String((char*)payload, length);
    Serial.printf("Message arrived [%s]: %s\n", topic, message.c_str());
    StaticJsonDocument<256> doc;
    DeserializationError error = deserializeJson(doc, payload, length);
    if (error) {
        Serial.printf("Failed to parse JSON: %s\n", error.c_str());
        return;
    }
    // Xử lý tin nhắn test kết nối
    if (strstr(topic, "iot/test") != NULL) {
        String clientId = doc["clientId"].as<String>();
        String timestamp = doc["timestamp"].as<String>();
        
        StaticJsonDocument<128> response;
        response["type"] = "connection_response";
        response["clientId"] = clientId;
        response["deviceId"] = "ESP32";
        response["timestamp"] = timestamp;
        response["status"] = "connected";        
        char responseBuffer[128];
        size_t n = serializeJson(response, responseBuffer);
        client.publish("iot/test_response", responseBuffer, n);
        Serial.printf("Sent test response: %s\n", responseBuffer);
        return;
    }
    // Xử lý yêu cầu trạng thái
    if (strstr(topic, "iot/device/status_request/") != NULL) {
        String device = String(topic).substring(String(topic).lastIndexOf('/') + 1);
        StaticJsonDocument<64> response;
        response["status"] = false;
        
        if (device == "light") {
            response["status"] = lightStatus;
        } else if (device == "roof") {
            response["status"] = isOpening;
        } else if (device == "pump") {
            response["status"] = pumpStatus;
        } else if (device == "fan") {
            response["status"] = fanStatus;
        }
        
        char responseBuffer[64];
        size_t n = serializeJson(response, responseBuffer);
        String responseTopic = "iot/device/status_response/" + device;
        client.publish(responseTopic.c_str(), responseBuffer, n);
        Serial.printf("Sent status response for %s: %s\n", device.c_str(), responseBuffer);
    }
    // Xử lý lệnh điều khiển thiết bị
    else if (strstr(topic, "iot/device/control/") != NULL) {
        String device = String(topic).substring(String(topic).lastIndexOf('/') + 1);
        bool status = doc["status"].as<bool>();
        if (device == "light") {
            digitalWrite(LIGHT_PIN, status ? LOW : HIGH);
            lightStatus = status;
            Serial.printf("Light turned %s\n", status ? "ON" : "OFF");
        }
        else if (device == "roof") {
            if (status && !isRunning) {
                motorOpen();
                isOpening = true;
                isRunning = true;
                Serial.println("Roof opening");
            } else if (!status && !isRunning) {
                motorClose();
                isOpening = false;
                isRunning = true;
                Serial.println("Roof closing");
            }
        }
        else if (device == "pump") {
            digitalWrite(PUMP_PIN, status ? LOW : HIGH);
            pumpStatus = status;
            Serial.printf("Pump turned %s\n", status ? "ON" : "OFF");
        }
        else if (device == "fan") {
            digitalWrite(FAN_PIN, status ? LOW : HIGH);
            fanStatus = status;
            Serial.printf("Fan turned %s\n", status ? "ON" : "OFF");
        }    
        // Gửi cập nhật trạng thái
        StaticJsonDocument<64> statusUpdate;
        statusUpdate["status"] = status;
        char statusBuffer[64];
        size_t n = serializeJson(statusUpdate, statusBuffer);
        String statusTopic = "iot/device/status/" + device;
        client.publish(statusTopic.c_str(), statusBuffer, n);
        Serial.printf("Published status update for %s: %s\n", device.c_str(), statusBuffer);
        updateDeviceStatus();
    }
}
// Kết nối lại MQTT
void reconnectMQTT() {
    while (!client.connected()) {
        Serial.print("Attempting MQTT connection...");
        if (client.connect("ESP32Client", MQTT_USERNAME, MQTT_PASSWORD)) {
            Serial.println("connected");      
            // Đăng ký các topic
            client.subscribe("iot/device/control/light");
            client.subscribe("iot/device/control/roof");
            client.subscribe("iot/device/control/pump");
            client.subscribe("iot/device/control/fan");      
            
            client.subscribe("iot/device/status_request/light");
            client.subscribe("iot/device/status_request/roof");
            client.subscribe("iot/device/status_request/pump");
            client.subscribe("iot/device/status_request/fan");      
            
            client.subscribe("iot/test");            
            client.subscribe("esp32/client");

            publishAllDeviceStatuses();
        } else {
            Serial.print("failed, rc=");
            Serial.print(client.state());
            Serial.println(" retrying in 5 seconds");
            delay(5000);
        }
    }
}
// Đọc cảm biến đất
bool readNPKData(SoilData& data) {
    digitalWrite(DE_PIN, HIGH);
    digitalWrite(RE_PIN, HIGH);
    delay(10); 
    npkSerial.write(QUERY_DATA, sizeof(QUERY_DATA));
    npkSerial.flush(); 
    digitalWrite(DE_PIN, LOW);
    digitalWrite(RE_PIN, LOW);
    delay(100);   
    if (npkSerial.available() < RESPONSE_SIZE) {
        Serial.println("Error: NPK sensor timeout or insufficient data");
        return false;
    }  
    byte response[RESPONSE_SIZE];
    npkSerial.readBytes(response, RESPONSE_SIZE);
    if (response[0] != 0x01) {
        Serial.println("Error: Invalid response from NPK sensor");
        return false;
    }  
    data.humidity = ((response[3] << 8) | response[4]) / 10.0;
    data.temperature = ((response[5] << 8) | response[6]) / 10.0;
    data.nitrogen = (response[11] << 8) | response[12];
    data.phosphorus = (response[13] << 8) | response[14];
    data.potassium = (response[15] << 8) | response[16];
    data.ph = ((response[9] << 8) | response[10]) / 10.0;  
    return true;
}
// Gửi dữ liệu lên MQTT và cập nhật TFT
void publishData(const SoilData& data) {
    StaticJsonDocument<256> doc;  
    doc["temperature"] = data.temperature;
    doc["humidity"] = data.humidity;
    doc["nitrogen"] = data.nitrogen;
    doc["phosphorus"] = data.phosphorus;
    doc["potassium"] = data.potassium;
    doc["ph"] = data.ph;

    char jsonBuffer[BUFFER_SIZE];
    size_t n = serializeJson(doc, jsonBuffer);
    client.publish("iot/sensor/data", (const uint8_t*)jsonBuffer, n, true);
    Serial.printf("Published JSON: %s\n", jsonBuffer);
    Serial.printf("T: %.2f, H: %.2f, N: %u, P: %u, K: %u, pH: %.2f\n",
                  data.temperature, data.humidity, data.nitrogen,
                  data.phosphorus, data.potassium, data.ph);
    // Cập nhật dữ liệu trên màn hình
    if (abs(data.temperature - lastData.temperature) >= 0.1) {
        tft.fillRect(10, 10, 230, 30, ILI9341_BLACK);
        tft.setCursor(10, 10);
        tft.setTextColor(ILI9341_YELLOW, ILI9341_BLACK);
        tft.setTextSize(3);
        tft.printf("T: %.1f", data.temperature);
        tft.print(" C");
        lastData.temperature = data.temperature;
    }
    if (abs(data.humidity - lastData.humidity) >= 0.1) {
        tft.fillRect(10, 40, 230, 30, ILI9341_BLACK);
        tft.setCursor(10, 40);
        tft.setTextColor(ILI9341_CYAN, ILI9341_BLACK);
        tft.setTextSize(3);
        tft.printf("H: %.1f", data.humidity);
        tft.print("%");
        lastData.humidity = data.humidity;
    }
    if (abs(data.nitrogen - lastData.nitrogen) >= 1) {
        tft.fillRect(10, 70, 230, 30, ILI9341_BLACK);
        tft.setCursor(10, 70);
        tft.setTextColor(ILI9341_WHITE);
        tft.setTextSize(3);
        tft.printf("N: %u mg/kg", data.nitrogen);
        lastData.nitrogen = data.nitrogen;
    }
    if (abs(data.phosphorus - lastData.phosphorus) >= 1) {
        tft.fillRect(10, 100, 230, 30, ILI9341_BLACK);
        tft.setCursor(10, 100);
        tft.setTextColor(ILI9341_WHITE);
        tft.printf("P: %u mg/kg", data.phosphorus);
        lastData.phosphorus = data.phosphorus;
    }
    if (abs(data.potassium - lastData.potassium) >= 1) {
        tft.fillRect(10, 130, 230, 30, ILI9341_BLACK);
        tft.setCursor(10, 130);
        tft.setTextColor(ILI9341_WHITE);
        tft.printf("K: %u mg/kg", data.potassium);
        lastData.potassium = data.potassium;
    }
    if (abs(data.ph - lastData.ph) >= 0.1) {
        tft.fillRect(10, 160, 230, 30, ILI9341_BLACK);
        tft.setCursor(10, 160);
        tft.setTextColor(ILI9341_MAGENTA);
        tft.setTextSize(3);
        tft.printf("PH: %.1f", data.ph);
        lastData.ph = data.ph;
    }
}
// Điều khiển motor
void motorOpen() {
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
}
void motorClose() {
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, HIGH);
}
void stopMotor() {
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, LOW);
}
// Đọc công tắc hành trình
bool readLimitSwitch(uint8_t pin, LimitSwitchState &ls) {
    bool reading = digitalRead(pin);
    if (reading != ls.lastReading) {
        ls.lastDebounceTime = millis();
    }
    if ((millis() - ls.lastDebounceTime) > DEBOUNCE_DELAY) {
        ls.state = reading;
    }
    ls.lastReading = reading;
    return ls.state;
}
// Xử lý nút nhấn
void handleButton(int index, uint8_t btnPin, uint8_t devicePin, bool &deviceStatus, const char* mqttTopic) {
    bool reading = digitalRead(btnPin);
    ButtonState &btn = buttons[index];    
    if (reading != btn.lastReading) {
        btn.lastDebounceTime = millis();
        btn.changed = false;
    }    
    if ((millis() - btn.lastDebounceTime) > DEBOUNCE_DELAY) {       
        if (reading != btn.state) {
            btn.state = reading;            
            if (btn.state == LOW && !btn.changed) {
                if (index == 1) { // Mái che
                    if (!isRunning) {
                        if (isOpening) {
                            motorClose();
                            isOpening = false;
                            isRunning = true;
                        } else {
                            motorOpen();
                            isOpening = true;
                            isRunning = true;
                        }
                        if (client.connected()) {
                            StaticJsonDocument<64> doc;
                            doc["status"] = isOpening;
                            char buffer[64];
                            size_t n = serializeJson(doc, buffer);
                            client.publish(mqttTopic, buffer, n);
                            Serial.printf("Button %d pressed, Roof: %s\n", index, isOpening ? "OPENING" : "CLOSING");
                        }
                    }
                } else { // Đèn hoặc máy bơm hoặc quạt
                    deviceStatus = !deviceStatus;
                    // digitalWrite(devicePin, deviceStatus ? HIGH : LOW);
                    digitalWrite(devicePin, deviceStatus ? LOW : HIGH);

                    Serial.printf("GPIO %d = %d\n", devicePin, digitalRead(devicePin));

                    if (client.connected()) {
                        StaticJsonDocument<64> doc;
                        doc["status"] = deviceStatus;
                        char buffer[64];
                        size_t n = serializeJson(doc, buffer);
                        client.publish(mqttTopic, buffer, n);
                        Serial.printf("Button %d pressed, Device: %s, Status: %s\n", 
                                    index, mqttTopic, deviceStatus ? "ON" : "OFF");
                    }
                }
                btn.changed = true;
                updateDeviceStatus();
            }
        }
    }    
    btn.lastReading = reading;
}
// Cập nhật trạng thái thiết bị lên màn hình
void updateDeviceStatus() {
    if (lightStatus != lastDeviceStatus.light) {
        tft.fillRect(10, 190, 230, 30, ILI9341_BLACK);
        tft.setCursor(10, 190);
        tft.setTextColor(lightStatus ? ILI9341_GREEN : ILI9341_RED);
        tft.setTextSize(3);
        tft.printf("LIGHT: %s", lightStatus ? "ON " : "OFF");
        lastDeviceStatus.light = lightStatus;
    }
    if (isOpening != lastDeviceStatus.roof) {
        tft.fillRect(10, 220, 230, 30, ILI9341_BLACK);
        tft.setCursor(10, 220);
        tft.setTextColor(isOpening ? ILI9341_GREEN : ILI9341_RED);
        tft.printf("ROOF : %s", isOpening ? "OPEN " : "CLOSE");
        lastDeviceStatus.roof = isOpening;
    }
    if (pumpStatus != lastDeviceStatus.pump) {
        tft.fillRect(10, 250, 230, 30, ILI9341_BLACK);
        tft.setCursor(10, 250);
        tft.setTextColor(pumpStatus ? ILI9341_GREEN : ILI9341_RED);
        tft.printf("PUMP : %s", pumpStatus ? "ON " : "OFF");
        lastDeviceStatus.pump = pumpStatus;
    }
    if (fanStatus != lastDeviceStatus.fan) {
        tft.fillRect(10, 280, 230, 30, ILI9341_BLACK);
        tft.setCursor(10, 280);
        tft.setTextColor(fanStatus ? ILI9341_GREEN : ILI9341_RED);
        tft.printf("FAN  : %s", fanStatus ? "ON " : "OFF");
        lastDeviceStatus.fan = fanStatus;
    }
}
// Gửi trạng thái thiết bị lên MQTT
void publishAllDeviceStatuses() {
    StaticJsonDocument<64> lightDoc;
    lightDoc["status"] = lightStatus;
    char lightBuffer[64];
    size_t n = serializeJson(lightDoc, lightBuffer);
    client.publish("iot/device/status/light", lightBuffer, n);
    Serial.printf("Published light status: %s\n", lightBuffer);

    StaticJsonDocument<64> roofDoc;
    roofDoc["status"] = isOpening;
    char roofBuffer[64];
    n = serializeJson(roofDoc, roofBuffer);
    client.publish("iot/device/status/roof", roofBuffer, n);
    Serial.printf("Published roof status: %s\n", roofBuffer);

    StaticJsonDocument<64> pumpDoc;
    pumpDoc["status"] = pumpStatus;
    char pumpBuffer[64];
    n = serializeJson(pumpDoc, pumpBuffer);
    client.publish("iot/device/status/pump", pumpBuffer, n);
    Serial.printf("Published pump status: %s\n", pumpBuffer);

    StaticJsonDocument<64> fanDoc;
    fanDoc["status"] = fanStatus;
    char fanBuffer[64];
    n = serializeJson(fanDoc, fanBuffer);
    client.publish("iot/device/status/fan", fanBuffer, n);
    Serial.printf("Published fan status: %s\n", fanBuffer);
}
// Chương trình chính
void loop() {
    static unsigned long lastUpdate = 0;
    if (!client.connected()) {
        reconnectMQTT();
    }
    client.loop();

    handleButton(0, LIGHT_BTN_PIN, LIGHT_PIN, lightStatus, "iot/device/status/light");
    handleButton(1, ROOF_BTN_PIN, 0, isOpening, "iot/device/status/roof");
    handleButton(2, PUMP_BTN_PIN, PUMP_PIN, pumpStatus, "iot/device/status/pump");
    handleButton(3, FAN_BTN_PIN, FAN_PIN, fanStatus, "iot/device/status/fan");

    if (isRunning) {
        bool openState = readLimitSwitch(limitSwitchOpen, limitSwitches[0]);
        bool closeState = readLimitSwitch(limitSwitchClose, limitSwitches[1]);
        if (!openState && isOpening) {
            stopMotor();
            isRunning = false;
            if (client.connected()) {
                StaticJsonDocument<64> doc;
                doc["status"] = isOpening;
                char buffer[64];
                size_t n = serializeJson(doc, buffer);
                client.publish("iot/device/status/roof", buffer, n);
                Serial.println("Roof fully opened");
            }
            updateDeviceStatus();
        } else if (!closeState && !isOpening) {
            stopMotor();
            isRunning = false;
            if (client.connected()) {
                StaticJsonDocument<64> doc;
                doc["status"] = isOpening;
                char buffer[64];
                size_t n = serializeJson(doc, buffer);
                client.publish("iot/device/status/roof", buffer, n);
                Serial.println("Roof fully closed");
            }
            updateDeviceStatus();
        }
    }

    if (millis() - lastUpdate >= UPDATE_INTERVAL) {
        SoilData data;
        if (readNPKData(data)) {
            publishData(data);
        } else {
            tft.fillRect(0, 0, 240, 180, ILI9341_BLACK);
            tft.setCursor(10, 10);
            tft.setTextColor(ILI9341_RED);
            tft.setTextSize(2);
            tft.println("NPK Sensor Error");
        }
        lastUpdate = millis();
    }

    if (millis() - lastDisplayUpdate >= DISPLAY_INTERVAL) {
        updateDeviceStatus();
        lastDisplayUpdate = millis();
    }
}